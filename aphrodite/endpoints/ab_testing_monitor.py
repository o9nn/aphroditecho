"""
A/B Testing Automated Monitoring and Rollback System
Phase 8 - SSR-Focused MLOps & Production Observability

Provides automated monitoring and rollback mechanisms for A/B tests.
"""
import asyncio
import time
from datetime import datetime, timezone
from typing import Dict, Any, Optional, Callable, List
from dataclasses import dataclass, asdict
from enum import Enum

from loguru import logger

from aphrodite.endpoints.middleware.ab_testing_middleware import (
    ABTestingManager, ABTestResult, get_ab_testing_manager
)


class AlertLevel(Enum):
    """Alert severity levels"""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    EMERGENCY = "emergency"


@dataclass
class MonitoringAlert:
    """Alert generated by monitoring system"""
    timestamp: str
    level: AlertLevel
    message: str
    test_id: str
    metrics: Dict[str, Any]
    action_taken: Optional[str] = None


class ABTestMonitor:
    """Automated monitoring system for A/B tests"""
    
    def __init__(self, 
                 ab_manager: ABTestingManager,
                 check_interval_seconds: int = 30,
                 alert_callback: Optional[Callable[[MonitoringAlert], None]] = None):
        self.ab_manager = ab_manager
        self.check_interval_seconds = check_interval_seconds
        self.alert_callback = alert_callback
        self.monitoring_task: Optional[asyncio.Task] = None
        self.alerts: List[MonitoringAlert] = []
        self.is_monitoring = False
        
        # Performance thresholds for automatic actions
        self.thresholds = {
            "critical_error_rate": 10.0,  # % - immediate rollback
            "warning_error_rate": 5.0,    # % - generate warning
            "critical_latency_ms": 3000.0,  # ms - immediate rollback  
            "warning_latency_ms": 1500.0,   # ms - generate warning
            "min_sample_size": 50,          # minimum requests before triggering actions
            "consecutive_failures_limit": 5  # consecutive check failures before rollback
        }
        
        self.consecutive_failures = 0
        self.last_check_time = 0.0
    
    async def start_monitoring(self):
        """Start automated monitoring"""
        if self.is_monitoring:
            logger.warning("A/B test monitoring already active")
            return
        
        self.is_monitoring = True
        self.consecutive_failures = 0
        self.monitoring_task = asyncio.create_task(self._monitoring_loop())
        logger.info(f"A/B test monitoring started with {self.check_interval_seconds}s intervals")
    
    async def stop_monitoring(self):
        """Stop automated monitoring"""
        self.is_monitoring = False
        
        if self.monitoring_task:
            self.monitoring_task.cancel()
            try:
                await self.monitoring_task
            except asyncio.CancelledError:
                pass
            self.monitoring_task = None
        
        logger.info("A/B test monitoring stopped")
    
    async def _monitoring_loop(self):
        """Main monitoring loop"""
        try:
            while self.is_monitoring:
                await self._perform_health_check()
                await asyncio.sleep(self.check_interval_seconds)
        except asyncio.CancelledError:
            logger.info("A/B test monitoring cancelled")
        except Exception as e:
            logger.error(f"Monitoring loop error: {e}")
            await self._generate_alert(
                AlertLevel.CRITICAL,
                f"Monitoring system failure: {e}",
                {}
            )
    
    async def _perform_health_check(self):
        """Perform comprehensive health check"""
        if not self.ab_manager.active_test:
            return
        
        try:
            test_status = self.ab_manager.get_test_status()
            if not test_status:
                return
            
            metrics_a = test_status["metrics"]["variant_a"]
            metrics_b = test_status["metrics"]["variant_b"]
            
            # Check if we have enough samples
            if (metrics_a["request_count"] < self.thresholds["min_sample_size"] and
                metrics_b["request_count"] < self.thresholds["min_sample_size"]):
                return
            
            # Check for critical conditions requiring immediate rollback
            rollback_required = await self._check_rollback_conditions(metrics_a, metrics_b, test_status)
            
            if rollback_required:
                await self._execute_emergency_rollback(test_status)
            else:
                # Check for warning conditions
                await self._check_warning_conditions(metrics_a, metrics_b, test_status)
            
            # Reset consecutive failures on successful check
            self.consecutive_failures = 0
            self.last_check_time = time.time()
            
        except Exception as e:
            self.consecutive_failures += 1
            logger.error(f"Health check failed (attempt {self.consecutive_failures}): {e}")
            
            # Emergency rollback if monitoring system itself is failing
            if self.consecutive_failures >= self.thresholds["consecutive_failures_limit"]:
                await self._execute_emergency_rollback({
                    "test_id": self.ab_manager.active_test.get("test_id", "unknown"),
                    "metrics": {"variant_a": {}, "variant_b": {}}
                }, reason="monitoring_system_failure")
    
    async def _check_rollback_conditions(self, metrics_a: Dict, metrics_b: Dict, test_status: Dict) -> bool:
        """Check if immediate rollback is required"""
        test_id = test_status["test_id"]
        
        # Critical error rate in variant B
        if metrics_b["error_rate"] >= self.thresholds["critical_error_rate"]:
            await self._generate_alert(
                AlertLevel.EMERGENCY,
                f"Critical error rate in variant B: {metrics_b['error_rate']:.2f}%",
                test_status,
                "emergency_rollback_initiated"
            )
            return True
        
        # Critical latency in variant B
        if metrics_b["avg_latency_ms"] >= self.thresholds["critical_latency_ms"]:
            await self._generate_alert(
                AlertLevel.EMERGENCY,
                f"Critical latency in variant B: {metrics_b['avg_latency_ms']:.2f}ms",
                test_status,
                "emergency_rollback_initiated"
            )
            return True
        
        # Significant performance degradation compared to variant A
        if (metrics_a["request_count"] > self.thresholds["min_sample_size"] and
            metrics_b["request_count"] > self.thresholds["min_sample_size"]):
            
            error_rate_increase = metrics_b["error_rate"] - metrics_a["error_rate"]
            latency_increase = metrics_b["avg_latency_ms"] - metrics_a["avg_latency_ms"]
            
            # More than 5x error rate increase
            if error_rate_increase > metrics_a["error_rate"] * 5:
                await self._generate_alert(
                    AlertLevel.EMERGENCY,
                    f"Variant B error rate {error_rate_increase:.2f}% higher than A",
                    test_status,
                    "emergency_rollback_initiated"
                )
                return True
            
            # More than 100% latency increase
            if metrics_a["avg_latency_ms"] > 0 and latency_increase > metrics_a["avg_latency_ms"]:
                await self._generate_alert(
                    AlertLevel.EMERGENCY,
                    f"Variant B latency {latency_increase:.2f}ms higher than A",
                    test_status,
                    "emergency_rollback_initiated"
                )
                return True
        
        return False
    
    async def _check_warning_conditions(self, metrics_a: Dict, metrics_b: Dict, test_status: Dict):
        """Check for warning conditions"""
        
        # Warning-level error rate
        if metrics_b["error_rate"] >= self.thresholds["warning_error_rate"]:
            await self._generate_alert(
                AlertLevel.WARNING,
                f"Elevated error rate in variant B: {metrics_b['error_rate']:.2f}%",
                test_status
            )
        
        # Warning-level latency
        if metrics_b["avg_latency_ms"] >= self.thresholds["warning_latency_ms"]:
            await self._generate_alert(
                AlertLevel.WARNING,
                f"Elevated latency in variant B: {metrics_b['avg_latency_ms']:.2f}ms",
                test_status
            )
        
        # Check test duration
        elapsed_minutes = test_status.get("elapsed_minutes", 0)
        max_duration = self.ab_manager.config.test_duration_minutes
        
        if elapsed_minutes >= max_duration:
            await self._generate_alert(
                AlertLevel.INFO,
                f"Test duration limit reached: {elapsed_minutes:.1f} minutes",
                test_status,
                "test_duration_limit_reached"
            )
    
    async def _execute_emergency_rollback(self, test_status: Dict, reason: str = "performance_degradation"):
        """Execute emergency rollback"""
        try:
            logger.critical(f"Executing emergency rollback for test {test_status['test_id']}")
            
            # Stop the A/B test with rollback decision
            result = await self.ab_manager.stop_ab_test(f"emergency_rollback_{reason}")
            result.decision = "rollback"
            result.reason = f"Emergency rollback: {reason}"
            
            await self._generate_alert(
                AlertLevel.EMERGENCY,
                f"Emergency rollback completed: {reason}",
                test_status,
                "emergency_rollback_completed"
            )
            
            # Stop monitoring since test is complete
            await self.stop_monitoring()
            
        except Exception as e:
            logger.error(f"Failed to execute emergency rollback: {e}")
            await self._generate_alert(
                AlertLevel.EMERGENCY,
                f"Emergency rollback failed: {e}",
                test_status,
                "rollback_failure"
            )
    
    async def _generate_alert(self, 
                            level: AlertLevel, 
                            message: str, 
                            test_status: Dict, 
                            action_taken: Optional[str] = None):
        """Generate and handle monitoring alert"""
        alert = MonitoringAlert(
            timestamp=datetime.now(timezone.utc).isoformat(),
            level=level,
            message=message,
            test_id=test_status.get("test_id", "unknown"),
            metrics=test_status.get("metrics", {}),
            action_taken=action_taken
        )
        
        self.alerts.append(alert)
        
        # Keep only last 1000 alerts to prevent memory issues
        if len(self.alerts) > 1000:
            self.alerts = self.alerts[-1000:]
        
        # Log the alert
        log_level = {
            AlertLevel.INFO: logger.info,
            AlertLevel.WARNING: logger.warning,
            AlertLevel.CRITICAL: logger.error,
            AlertLevel.EMERGENCY: logger.critical
        }[level]
        
        log_level(f"A/B_TEST_ALERT: {alert.message} [Test: {alert.test_id}]")
        
        # Call external alert callback if provided
        if self.alert_callback:
            try:
                self.alert_callback(alert)
            except Exception as e:
                logger.error(f"Alert callback failed: {e}")
    
    def get_alert_history(self, limit: int = 100) -> List[Dict[str, Any]]:
        """Get recent alert history"""
        recent_alerts = self.alerts[-limit:] if limit > 0 else self.alerts
        return [asdict(alert) for alert in recent_alerts]
    
    def get_monitoring_status(self) -> Dict[str, Any]:
        """Get current monitoring status"""
        return {
            "is_monitoring": self.is_monitoring,
            "check_interval_seconds": self.check_interval_seconds,
            "consecutive_failures": self.consecutive_failures,
            "last_check_time": self.last_check_time,
            "thresholds": self.thresholds,
            "total_alerts": len(self.alerts),
            "recent_alerts": len([a for a in self.alerts 
                                if (time.time() - datetime.fromisoformat(a.timestamp.replace('Z', '+00:00')).timestamp()) < 3600])
        }


class ABTestAutoRollback:
    """Automated rollback system for A/B tests"""
    
    def __init__(self):
        self.monitor: Optional[ABTestMonitor] = None
        self.rollback_callbacks: List[Callable[[ABTestResult], None]] = []
    
    def register_rollback_callback(self, callback: Callable[[ABTestResult], None]):
        """Register callback for rollback events"""
        self.rollback_callbacks.append(callback)
    
    def setup_monitoring(self, 
                        ab_manager: Optional[ABTestingManager] = None,
                        check_interval_seconds: int = 30,
                        alert_callback: Optional[Callable[[MonitoringAlert], None]] = None) -> ABTestMonitor:
        """Setup automated monitoring for A/B tests"""
        if not ab_manager:
            ab_manager = get_ab_testing_manager()
        
        self.monitor = ABTestMonitor(ab_manager, check_interval_seconds, alert_callback)
        return self.monitor
    
    async def start_monitoring_for_test(self, test_id: str):
        """Start monitoring for a specific test"""
        if not self.monitor:
            raise ValueError("Monitoring not configured. Call setup_monitoring first.")
        
        await self.monitor.start_monitoring()
        logger.info(f"Automated monitoring started for A/B test {test_id}")
    
    async def stop_monitoring(self):
        """Stop all monitoring"""
        if self.monitor:
            await self.monitor.stop_monitoring()


# Global automated rollback system
_auto_rollback_system: Optional[ABTestAutoRollback] = None


def get_auto_rollback_system() -> ABTestAutoRollback:
    """Get or create the global auto-rollback system"""
    global _auto_rollback_system
    if _auto_rollback_system is None:
        _auto_rollback_system = ABTestAutoRollback()
    return _auto_rollback_system


def initialize_ab_monitoring(check_interval_seconds: int = 30) -> ABTestMonitor:
    """Initialize A/B testing monitoring system"""
    auto_rollback = get_auto_rollback_system()
    
    def alert_handler(alert: MonitoringAlert):
        """Default alert handler"""
        if alert.level in (AlertLevel.CRITICAL, AlertLevel.EMERGENCY):
            # In production, this could send notifications, create tickets, etc.
            logger.critical(f"A/B TEST CRITICAL ALERT: {alert.message}")
    
    return auto_rollback.setup_monitoring(
        check_interval_seconds=check_interval_seconds,
        alert_callback=alert_handler
    )