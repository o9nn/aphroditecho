name: üîß Self-Healing Workflow System

# This workflow monitors for blocking errors and automatically creates issues with assignment to dtecho and drzo

on:
  # Trigger on workflow failures
  workflow_run:
    workflows: ["üöÄ Aphrodite Engine Build Automation", "Generate Next Steps Issues", "Echo Systems Integration"]
    types: [completed]
    
  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      error_type:
        description: 'Type of error to simulate'
        required: false
        default: 'test'
        type: choice
        options:
          - test
          - build_failure
          - test_failure
          - deployment_failure
          - critical_error
      severity:
        description: 'Error severity level'
        required: false
        default: 'medium'
        type: choice
        options:
          - low
          - medium
          - high
          - critical
          
  # Trigger on specific error conditions
  push:
    branches: [ main, develop ]
    paths:
      - '.github/workflows/**'
      - 'setup.py'
      - 'pyproject.toml'
      - 'CMakeLists.txt'
      
  pull_request:
    branches: [ main, develop ]
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  issues: write
  actions: read
  checks: read
  pull-requests: read

env:
  # Assignees for auto-generated issues
  DEFAULT_ASSIGNEES: "dtecho,drzo"
  # Labels for categorization
  ERROR_LABEL_PREFIX: "blocking-error"
  SELF_HEALING_LABEL: "self-healing"

jobs:
  detect-errors:
    name: üîç Error Detection & Analysis
    runs-on: ubuntu-latest
    outputs:
      has-errors: ${{ steps.analyze.outputs.has-errors }}
      error-summary: ${{ steps.analyze.outputs.error-summary }}
      error-type: ${{ steps.analyze.outputs.error-type }}
      severity: ${{ steps.analyze.outputs.severity }}
      affected-components: ${{ steps.analyze.outputs.affected-components }}
      logs-artifact: ${{ steps.analyze.outputs.logs-artifact }}
      
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: üêç Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: üì¶ Install Analysis Dependencies
        run: |
          pip install requests pygithub python-dateutil pyyaml

      - name: üîç Analyze Errors
        id: analyze
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WORKFLOW_RUN_ID: ${{ github.event.workflow_run.id }}
          MANUAL_ERROR_TYPE: ${{ github.event.inputs.error_type }}
          MANUAL_SEVERITY: ${{ github.event.inputs.severity }}
        run: |
          python << 'EOF'
          import os
          import json
          import sys
          from datetime import datetime, timedelta
          from github import Github
          import re

          # Initialize GitHub API
          g = Github(os.environ['GITHUB_TOKEN'])
          repo = g.get_repo(os.environ['GITHUB_REPOSITORY'])

          def analyze_workflow_run(run_id):
              """Analyze a specific workflow run for errors"""
              try:
                  run = repo.get_workflow_run(int(run_id))
                  
                  # Get job logs and analyze for errors
                  jobs = run.get_jobs()
                  errors = []
                  
                  for job in jobs:
                      if job.conclusion in ['failure', 'cancelled', 'timed_out']:
                          error_info = {
                              'job_name': job.name,
                              'conclusion': job.conclusion,
                              'started_at': job.started_at.isoformat() if job.started_at else None,
                              'completed_at': job.completed_at.isoformat() if job.completed_at else None,
                              'logs_url': job.logs_url if hasattr(job, 'logs_url') else None
                          }
                          errors.append(error_info)
                  
                  return {
                      'workflow_name': run.name,
                      'conclusion': run.conclusion,
                      'errors': errors,
                      'run_url': run.html_url,
                      'run_id': run.id
                  }
              except Exception as e:
                  print(f"Error analyzing workflow run: {e}")
                  return None

          def detect_error_patterns(repo):
              """Detect common error patterns in recent activity"""
              errors = []
              now = datetime.now()
              since = now - timedelta(hours=24)
              
              # Check recent workflow runs
              workflows = repo.get_workflows()
              for workflow in workflows:
                  try:
                      runs = workflow.get_runs(created=f">={since.isoformat()}")
                      for run in runs:
                          if run.conclusion == 'failure':
                              errors.append({
                                  'type': 'workflow_failure',
                                  'workflow': workflow.name,
                                  'run_id': run.id,
                                  'created_at': run.created_at.isoformat(),
                                  'html_url': run.html_url
                              })
                  except Exception as e:
                      print(f"Error checking workflow {workflow.name}: {e}")
                      continue
              
              # Check for build failures in commits
              commits = repo.get_commits(since=since)
              for commit in commits:
                  try:
                      status = commit.get_combined_status()
                      if status.state == 'failure':
                          errors.append({
                              'type': 'build_failure',
                              'commit_sha': commit.sha,
                              'commit_message': commit.commit.message[:100],
                              'created_at': commit.commit.author.date.isoformat(),
                              'html_url': commit.html_url
                          })
                  except Exception as e:
                      print(f"Error checking commit {commit.sha}: {e}")
                      continue
              
              return errors

          def categorize_error(error_info):
              """Categorize error and determine severity"""
              error_type = 'unknown'
              severity = 'medium'
              affected_components = []
              
              if 'workflow' in error_info:
                  workflow_name = error_info['workflow'].lower()
                  
                  if 'build' in workflow_name:
                      error_type = 'build_failure'
                      severity = 'high'
                      affected_components = ['build-system', 'ci-cd']
                  elif 'test' in workflow_name:
                      error_type = 'test_failure'
                      severity = 'medium'
                      affected_components = ['testing', 'quality-assurance']
                  elif 'deploy' in workflow_name:
                      error_type = 'deployment_failure'
                      severity = 'critical'
                      affected_components = ['deployment', 'infrastructure']
                  elif 'echo' in workflow_name:
                      error_type = 'echo_system_failure'
                      severity = 'high'
                      affected_components = ['deep-tree-echo', 'aar-orchestration']
              
              # Check for specific error patterns
              if error_info.get('type') == 'build_failure':
                  error_type = 'build_failure'
                  severity = 'high'
                  affected_components = ['build-system', 'compilation']
              
              return error_type, severity, affected_components

          # Main analysis logic
          has_errors = False
          error_summary = ""
          error_type = "none"
          severity = "low"
          affected_components = []

          # Check if this is a manual trigger
          manual_error = os.environ.get('MANUAL_ERROR_TYPE')
          if manual_error and manual_error != 'test':
              has_errors = True
              error_type = manual_error
              severity = os.environ.get('MANUAL_SEVERITY', 'medium')
              error_summary = f"Manual error simulation: {error_type} (severity: {severity})"
              affected_components = ['manual-testing']
          else:
              # Check workflow run that triggered this
              workflow_run_id = os.environ.get('WORKFLOW_RUN_ID')
              if workflow_run_id:
                  run_analysis = analyze_workflow_run(workflow_run_id)
                  if run_analysis and run_analysis['conclusion'] == 'failure':
                      has_errors = True
                      error_type, severity, affected_components = categorize_error(run_analysis)
                      error_summary = f"Workflow failure: {run_analysis['workflow_name']}"
              
              # Detect other error patterns
              recent_errors = detect_error_patterns(repo)
              if recent_errors and not has_errors:
                  # Focus on most recent critical error
                  critical_errors = [e for e in recent_errors if 'build' in e.get('workflow', '').lower()]
                  if critical_errors:
                      has_errors = True
                      latest_error = critical_errors[0]
                      error_type, severity, affected_components = categorize_error(latest_error)
                      error_summary = f"Recent {error_type}: {latest_error.get('workflow', 'Unknown')}"

          # Output results
          print(f"::set-output name=has-errors::{str(has_errors).lower()}")
          print(f"::set-output name=error-summary::{error_summary}")
          print(f"::set-output name=error-type::{error_type}")
          print(f"::set-output name=severity::{severity}")
          print(f"::set-output name=affected-components::{','.join(affected_components)}")
          print(f"::set-output name=logs-artifact::error-logs-{datetime.now().strftime('%Y%m%d-%H%M%S')}")

          # Create error analysis file
          analysis_data = {
              'has_errors': has_errors,
              'error_summary': error_summary,
              'error_type': error_type,
              'severity': severity,
              'affected_components': affected_components,
              'timestamp': datetime.now().isoformat(),
              'repository': os.environ['GITHUB_REPOSITORY'],
              'workflow_run_id': workflow_run_id,
              'analysis_trigger': 'manual' if manual_error else 'automatic'
          }

          with open('error-analysis.json', 'w') as f:
              json.dump(analysis_data, f, indent=2)

          print("Error analysis completed")
          print(f"Has errors: {has_errors}")
          print(f"Error type: {error_type}")
          print(f"Severity: {severity}")
          EOF

      - name: üìä Upload Error Analysis
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ${{ steps.analyze.outputs.logs-artifact }}
          path: error-analysis.json
          retention-days: 30

  create-healing-issues:
    name: üîß Create Self-Healing Issues
    runs-on: ubuntu-latest
    needs: detect-errors
    if: needs.detect-errors.outputs.has-errors == 'true'
    permissions:
      issues: write
      contents: read
    
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

      - name: üì• Download Error Analysis
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.detect-errors.outputs.logs-artifact }}

      - name: üêç Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: üì¶ Install Dependencies
        run: |
          pip install pygithub python-dateutil

      - name: üîß Create Self-Healing Issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ERROR_SUMMARY: ${{ needs.detect-errors.outputs.error-summary }}
          ERROR_TYPE: ${{ needs.detect-errors.outputs.error-type }}
          SEVERITY: ${{ needs.detect-errors.outputs.severity }}
          AFFECTED_COMPONENTS: ${{ needs.detect-errors.outputs.affected-components }}
        run: |
          python << 'EOF'
          import os
          import json
          import sys
          from datetime import datetime
          from github import Github

          # Load error analysis
          with open('error-analysis.json', 'r') as f:
              analysis = json.load(f)

          # Initialize GitHub API
          g = Github(os.environ['GITHUB_TOKEN'])
          repo = g.get_repo(os.environ['GITHUB_REPOSITORY'])

          def create_issue_title(error_type, severity):
              """Create descriptive issue title"""
              severity_emoji = {
                  'low': 'üü°',
                  'medium': 'üü†', 
                  'high': 'üî¥',
                  'critical': 'üö®'
              }
              
              error_titles = {
                  'build_failure': 'Build System Failure',
                  'test_failure': 'Test Suite Failure',
                  'deployment_failure': 'Deployment Pipeline Failure',
                  'echo_system_failure': 'Deep Tree Echo System Failure',
                  'critical_error': 'Critical System Error',
                  'unknown': 'System Error'
              }
              
              emoji = severity_emoji.get(severity, '‚ö†Ô∏è')
              title = error_titles.get(error_type, 'System Error')
              
              return f"{emoji} [BLOCKING] {title} - Auto-Generated"

          def create_issue_body(analysis):
              """Create detailed issue body with diagnostics"""
              timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')
              
              body = f"""## üö® Blocking Error Detected - Self-Healing System Alert

          **Auto-generated by the Self-Healing Workflow System**
          **Detection Time**: {timestamp}
          **Severity**: {analysis['severity'].upper()}
          **Error Type**: {analysis['error_type']}

          ### üìã Error Summary
          {analysis['error_summary']}

          ### üéØ Affected Components
          {', '.join(analysis['affected_components']) if analysis['affected_components'] else 'Not determined'}

          ### üîç Diagnostic Information
          - **Repository**: {analysis['repository']}
          - **Analysis Trigger**: {analysis['analysis_trigger']}
          - **Workflow Run ID**: {analysis.get('workflow_run_id', 'N/A')}
          - **Detection Method**: Automated error pattern analysis

          ### üõ†Ô∏è Immediate Actions Required

          #### For @dtecho and @drzo:
          - [ ] **Acknowledge** this blocking error within 2 hours
          - [ ] **Investigate** root cause using provided diagnostic information
          - [ ] **Assess** impact on Deep Tree Echo and AAR systems
          - [ ] **Implement** immediate fix or workaround
          - [ ] **Verify** fix resolves the blocking condition
          - [ ] **Update** this issue with resolution details

          ### üîÑ Self-Healing Actions Attempted
          - [x] Error detection and analysis completed
          - [x] Issue creation and assignment automated
          - [ ] Rollback procedures (manual intervention required)
          - [ ] System recovery validation (pending fix)

          ### üìä Error Pattern Analysis
          ```json
          {json.dumps(analysis, indent=2)}
          ```

          ### üöÄ Recovery Procedures

          #### Immediate Recovery Steps:
          1. **Check System Status**: Verify core services are operational
          2. **Review Recent Changes**: Identify potential breaking changes
          3. **Run Diagnostics**: Execute system health checks
          4. **Apply Hotfix**: Implement immediate resolution
          5. **Monitor Systems**: Ensure stability post-fix

          #### Build Failure Recovery:
          ```bash
          # Check build environment
          export APHRODITE_TARGET_DEVICE=cpu
          python setup.py build_ext --inplace
          
          # Run diagnostic build
          cmake --build build --target _C -j1 --verbose
          ```

          #### Test Failure Recovery:
          ```bash
          # Run specific failing tests
          pytest tests/ -v --tb=short -x
          
          # Check test environment
          python -c "from aphrodite import LLM, SamplingParams; print('‚úÖ Core imports successful')"
          ```

          ### üìà Monitoring & Alerts
          - **Issue Priority**: HIGH - Blocking development/deployment
          - **SLA Target**: Resolution within 4 hours
          - **Escalation**: If unresolved after 6 hours, escalate to team leads
          - **Follow-up**: Post-mortem required for critical/high severity errors

          ### üîó Related Resources
          - [Build System Documentation](CONTRIBUTING.md)
          - [Troubleshooting Guide](GITHUB_ACTIONS_GUIDE.md)
          - [Deep Tree Echo Architecture](DEEP_TREE_ECHO_ARCHITECTURE.md)
          - [Self-Healing Workflow Source](.github/workflows/self-healing-workflow.yml)

          ### üè∑Ô∏è Automatic Classification
          This issue was automatically created by the self-healing workflow system. It represents a blocking condition that requires immediate attention from the development team.

          **Expected Resolution Time**: {
              '30 minutes' if analysis['severity'] == 'critical' else
              '2 hours' if analysis['severity'] == 'high' else
              '4 hours' if analysis['severity'] == 'medium' else
              '8 hours'
          }

          ---
          *ü§ñ Generated by Self-Healing Workflow System | [View Workflow Run](https://github.com/{analysis['repository']}/actions/runs/{os.environ.get('GITHUB_RUN_ID', 'N/A')})*
          """
              return body

          # Create issue
          title = create_issue_title(analysis['error_type'], analysis['severity'])
          body = create_issue_body(analysis)
          
          # Determine labels
          labels = [
              os.environ.get('ERROR_LABEL_PREFIX', 'blocking-error'),
              os.environ.get('SELF_HEALING_LABEL', 'self-healing'),
              f"severity-{analysis['severity']}",
              f"type-{analysis['error_type']}",
              'auto-generated'
          ]
          
          # Add component-specific labels
          if analysis['affected_components']:
              labels.extend(analysis['affected_components'])

          # Check for existing similar issues
          existing_issues = repo.get_issues(
              state='open', 
              labels=[os.environ.get('ERROR_LABEL_PREFIX', 'blocking-error')]
          )
          
          duplicate_found = False
          for issue in existing_issues:
              if analysis['error_type'] in issue.title.lower():
                  # Update existing issue instead of creating duplicate
                  comment = f"""## üîÑ Additional Error Instance Detected

          **Detection Time**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
          **Error Type**: {analysis['error_type']}
          **Severity**: {analysis['severity']}

          This error pattern has occurred again. Please prioritize resolution.

          ### Latest Analysis:
          ```json
          {json.dumps(analysis, indent=2)}
          ```
          """
                  issue.create_comment(comment)
                  print(f"Updated existing issue #{issue.number}: {issue.title}")
                  duplicate_found = True
                  break

          if not duplicate_found:
              # Create new issue
              issue = repo.create_issue(
                  title=title,
                  body=body,
                  labels=labels,
                  assignees=os.environ.get('DEFAULT_ASSIGNEES', '').split(',')
              )
              print(f"Created issue #{issue.number}: {issue.title}")
              
              # Add immediate comment for urgency
              if analysis['severity'] in ['high', 'critical']:
                  urgency_comment = f"""## üö® URGENT: {analysis['severity'].upper()} Severity Error

          This is a {analysis['severity']} severity blocking error that requires immediate attention.

          **@dtecho @drzo** - Please acknowledge and begin investigation immediately.

          **Expected Response Time**: {
              '15 minutes' if analysis['severity'] == 'critical' else '30 minutes'
          }
          """
                  issue.create_comment(urgency_comment)

          print("Self-healing issue creation completed")
          EOF

  # Recovery and rollback procedures
  attempt-auto-recovery:
    name: üîÑ Attempt Automatic Recovery
    runs-on: ubuntu-latest
    needs: [detect-errors, create-healing-issues]
    if: needs.detect-errors.outputs.has-errors == 'true' && needs.detect-errors.outputs.severity != 'critical'
    
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

      - name: üîÑ Attempt Basic Recovery
        env:
          ERROR_TYPE: ${{ needs.detect-errors.outputs.error-type }}
          SEVERITY: ${{ needs.detect-errors.outputs.severity }}
        run: |
          echo "üîÑ Attempting automatic recovery for: $ERROR_TYPE"
          
          case $ERROR_TYPE in
            build_failure)
              echo "Attempting build recovery..."
              # Clean build artifacts
              rm -rf build/ dist/ *.egg-info/ || true
              # Clear ccache
              ccache -C || true
              echo "Build cleanup completed"
              ;;
            test_failure)
              echo "Attempting test environment recovery..."
              # Clean test artifacts
              find . -name "*.pyc" -delete || true
              find . -name "__pycache__" -exec rm -rf {} + || true
              echo "Test cleanup completed"
              ;;
            *)
              echo "No automatic recovery available for: $ERROR_TYPE"
              ;;
          esac

  # Monitoring and status reporting
  update-monitoring:
    name: üìä Update Monitoring Dashboard
    runs-on: ubuntu-latest
    needs: [detect-errors, create-healing-issues, attempt-auto-recovery]
    if: always()
    
    steps:
      - name: üìä Update Status Dashboard
        run: |
          echo "## üîß Self-Healing System Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "**Repository**: ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Error Detection Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Errors Detected**: ${{ needs.detect-errors.outputs.has-errors }}" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.detect-errors.outputs.has-errors }}" == "true" ]]; then
            echo "- **Error Type**: ${{ needs.detect-errors.outputs.error-type }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Severity**: ${{ needs.detect-errors.outputs.severity }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Summary**: ${{ needs.detect-errors.outputs.error-summary }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Issue Created**: ‚úÖ" >> $GITHUB_STEP_SUMMARY
            echo "- **Assigned To**: dtecho, drzo" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Status**: ‚úÖ No blocking errors detected" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.detect-errors.outputs.has-errors }}" == "true" ]]; then
            echo "1. **Immediate**: Check created issue for detailed diagnostics" >> $GITHUB_STEP_SUMMARY
            echo "2. **Investigation**: Review logs and recent changes" >> $GITHUB_STEP_SUMMARY
            echo "3. **Resolution**: Implement fix and verify system recovery" >> $GITHUB_STEP_SUMMARY
            echo "4. **Prevention**: Update monitoring to prevent recurrence" >> $GITHUB_STEP_SUMMARY
          else
            echo "- Continue with normal development workflow" >> $GITHUB_STEP_SUMMARY
            echo "- Monitor for future error patterns" >> $GITHUB_STEP_SUMMARY
          fi